/*
  Copyright (c) 2023 Lightstreamer Srl

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/
import SimpleLogger from "./SimpleLogger";
import SimpleLogLevels from "./SimpleLogLevels";

export default /*@__PURE__*/(function() {
  /**
   * @private
   */
  function logHeader() {
    var _line = (typeof window != "undefined") ? (window.name + " ") : "";
    var i = 0;
    var now = new Date();
    
    i = now.getHours();
    if ( i < 10 ) {
      _line += "0";
    }
    _line += i;
    _line += ":";
    
    i = now.getMinutes();
    if ( i < 10 ) {
      _line += "0";
    }
    _line += i;
    _line += ":";
         
    i = now.getSeconds();
    if ( i < 10 ) {
      _line += "0";
    }
    _line += i;
    _line += ",";
    
    _line += now.getMilliseconds();
    
    return _line;
  };  
  
  /**
   * Empty constructor for SimpleLoggerProvider. 
   * @constructor
   *
   * @exports SimpleLoggerProvider
   * 
   * @class SimpleLoggerProvider implementation that can be used to consume logging
   * from the {@link module:LoggerManager}. 
   * To enable client logging, an instance of this class has to be created and supplied through the
   * {@link module:LoggerManager.setLoggerProvider} method before any log can be 
   * consumed.
   * <br/>In order to determine how to consume the log, one or multiple "appenders"
   * can be supplied to this object, through {@link SimpleLoggerProvider#addLoggerAppender}.
   * The {@link Logger} instances created by this LoggerProvider for the various log categories
   * will forward the log lines to the appenders, based on the appender preferences configured.
   * Category and level filters are available and can be configured on each appender.
   * <br/>Several appender classes are distributed with the library in 
   * order to enable custom code to consume the log in different ways:
   * {@link ConsoleAppender}, {@link AlertAppender},
   * {@link DOMAppender}, {@link FunctionAppender} and {@link BufferAppender}.  
   * <BR>
   * <BR>The SimpleLoggerProvider is available for the implementation of custom logging;
   * just invoke the {@link LoggerProvider#getLogger} method to get {@link Logger}
   * objects for custom categories, then invoke the various methods available on the
   * loggers to produce log messages to be handled by the configured appenders.
   *
   * @extends LoggerProvider
   */
  var SimpleLoggerProvider = function() { ////extend EventDispatcher?

    this.appenders = [];
    this.logInstances = {};
  };
  
  
  SimpleLoggerProvider.prototype = {
     
    /**
     * @private
     */     
     minPriority: function() { // @return {Number} min log level supported by the appenders;
      var min = 100;
      var champion = 0;
      if (this.appenders.length > 0) {
        for (var i=0; i<this.appenders.length; i++) {
          if ( SimpleLogLevels.priority(this.appenders[i].getLevel()) < min ) {
            min = SimpleLogLevels.priority(this.appenders[i].getLevel());
            champion = i;
          }
        }
        
        return this.appenders[champion].getLevel();
      } else {
        return null;
      }
    },
    
    /**
     * @private
     */     
    setLoggerLevel: function(level) {
      for (var key in this.logInstances) {
        this.logInstances[key].setLevel(level);
      }
    },
    
    /**
     * @private
     */
    checkCategoryFilter: function(_appender, category) { //Check the filter categories for a loggerAppender. 
      var appenderFilter;
      var allAppenderCategories=[];
      
      if (_appender.getCategoryFilter() === "*") {
        return true;
      } else {
        appenderFilter = _appender.getCategoryFilter();
        allAppenderCategories = appenderFilter.split(" ");
        for (var i=0; i<allAppenderCategories.length; i++) {
          if (allAppenderCategories[i] == category) {
            return true;
          }
        }
        
        return false;
      }
    },
    
    /**
     * Adds a {@link SimpleLogAppender} to this SimpleLoggerProvider instance. Such appender 
     * will receive log lines from the Logger instances generated by this SimpleLoggerProvider instance. 
     * The appender defines a category and a threshold level, 
     * so that it will receive only the log lines with a level equal to or greater
     * than the threshold and only from the Logger associated with the requested category.
     *
     * <br/>Appenders can be added at any time; any loggers already created
     * by this SimpleLoggerProvider instance will start using the new appender.
     * Until the first appender is added, all log will be discarded.
     * 
     * @param {SimpleLogAppender} logAppender An instance of SimpleLogAppender that will consume
     * the log.
     */ 
    addLoggerAppender: function(logAppender) {
      if ( logAppender && logAppender.log && logAppender.getLevel ) {
        this.appenders.push(logAppender);
        if ( logAppender.setLoggerProvider ) {
          logAppender.setLoggerProvider(this);
        }
      }
      this.setLoggerLevel(this.minPriority());
    },
    
    /**
     * Removes a {@link SimpleLogAppender} from this SimpleLoggerProvider instance.
     * <br/>Appenders can be removed at any time.
     *
     * @param {SimpleLogAppender} logAppender An instance of SimpleLogAppender that was previously 
     * added to this SimpleLoggerProvider instance.
     * 
     * @see SimpleLoggerProvider#addLoggerAppender
     */
    removeLoggerAppender: function(logAppender) {
      for (var i=0; i<this.appenders.length; i++) {
        if ( this.appenders[i] === logAppender) {
          this.appenders.splice(i,1);
          this.setLoggerLevel(this.minPriority());
          return;
        }
      }
    },
    
    
    /** 
     * @private
     */
    forceLogLevelUpdate: function() {
      //Force update of log level of all loggers upon the min level of all log appernders.
      //Used by logAppenders instances when a setLevel operation has been performed. 
      this.setLoggerLevel(this.minPriority());
    },
    
    /**
     * Logger factory that gets a logger related to a specified category name.
     * If such logger does not exist it is created.
     * A unique instance is always maintained for each logger name.
     * This method can potentially cause a memory leak as once a Logger 
     * is created it will never be dismissed. It is expected that the number of 
     * categories within a single application is somewhat limited and in any case
     * not growing with time.
     *
     * @param {String} category The name of the desired log category. 
     *
     * @return {Logger} The desired Logger instance.
     */
    getLogger: function(category) {
      if ( !this.logInstances[category] ) {
        this.logInstances[category] = new SimpleLogger(this, category);
        if (this.appenders.length > 0)
          this.logInstances[category].setLevel(this.minPriority());
      }
      return this.logInstances[category];
    },
    

    
    /**
     * Publish a log message on all SimpleLogAppender object instances added to this SimpleLoggerProvider so far.
     * 
     * @param {String} category The category name that produced the given message.
     * @param {String} level The logging level of the given message. It should be one of DEBUG INFO WARN ERROR FATAL
     * constants values. 
     * @param {*} mex The message to be logged. It could be a String instance, an Error instance or any other
     * object, provided that it has a toString method.
     * 
     */
    dispatchLog: function(category, level, mex) {
      var header = logHeader();
      var priority = SimpleLogLevels.priority(level);
      for (var i=0; i<this.appenders.length; i++) {
        if ( SimpleLogLevels.priority(this.appenders[i].getLevel()) <= priority ) {
          if (this.checkCategoryFilter(this.appenders[i],category)) {
            this.appenders[i].log(category, level, mex, header);
          }
        }
      }
    }
  };
  
  //google closure exports
  SimpleLoggerProvider.prototype["addLoggerAppender"] = SimpleLoggerProvider.prototype.addLoggerAppender;
  SimpleLoggerProvider.prototype["removeLoggerAppender"] = SimpleLoggerProvider.prototype.removeLoggerAppender;
  SimpleLoggerProvider.prototype["getLogger"] = SimpleLoggerProvider.prototype.getLogger;
  SimpleLoggerProvider.prototype["dispatchLog"] = SimpleLoggerProvider.prototype.dispatchLog;
  
  return SimpleLoggerProvider;
})();


//JSDOC_IGNORE_END